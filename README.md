# Advent of Code
This repository contains my solutions for the annual Advent of Code programming puzzles. Input data and problem description can be viewed in the Advent of Code website. I didn't participate the competition that happens in december and you have one day to solve the challenge. I solved them at my own pace, taking few days for each one.

# What is Advent of Code?
Advent of Code is an annual series of small programming challenges, released daily from December 1st to December 25th. Each day presents a new two-part puzzle that can be solved using any programming language. It's a fantastic way to practice problem-solving, learn new algorithms and data structures, and improve your coding skills.

You can learn more about Advent of Code and participate yourself at adventofcode.com.

# What I learned from those challenges ?
For me it was a good experience where each challenge presented a new problem and you had to figure it out the solution. 
I tried to solve by myself and when got stuck I would read about how other programmers solved and then could make some progress. The best feeling is when you find that you are on the right direction trying to find the solution by yourself!

# Some general concepts that are used in the challenges.
- Graph Theory Fundamentals: Understanding and implementing algorithms like Breadth-First Search (BFS) and Depth-First Search (DFS) for pathfinding or connectivity problems.
- Dynamic Programming: Recognizing when a problem can be solved by breaking it into overlapping subproblems and storing results to avoid recomputation. This is a common pattern for optimizing solutions to complex problems.
- Recursion: Developing elegant solutions for problems that can be defined in terms of smaller instances of themselves.
- Advanced Data Structures: Using sets for unique elements, queues for ordered processing, and stacks for LIFO (Last-In, First-Out) operations.

# General Learning Across All Challenges
- Problem-Solving Skills: The core of Advent of Code is improving your ability to analyze a problem, devise a plan, and implement it.
- Debugging: Identifying and fixing errors in your code, especially as problems become more intricate.
- Testing: Developing good testing habits to ensure your solution works for various edge cases and the full input.
- Language Proficiency: Becoming more comfortable and fluent in your chosen programming language by applying its features to diverse problems.
- Reading Documentation: Often, the efficient solution relies on a built-in function or library that you might not be familiar with, encouraging you to explore language documentation.
- Community Learning: Observing how others solve the same problems (after solving them by myself) can expose you to new techniques, algorithms, and elegant coding styles.
- Persistence and Resilience: Some problems are truly challenging, and sticking with them, even when stuck, fosters valuable problem-solving resilience.

# What's next ?
I'm thinking to do the other challenges, but maybe use a different programming language.
